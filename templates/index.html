<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tauqeer Ali Khan Chatbot</title>
    <style>
        /* Base Styling & Utility Classes (from your original file) */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .w-full { width: 100%; }
        .max-w-lg { max-width: 32rem; }
        .bg-white { background-color: #fff; }
        .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        .rounded-xl { border-radius: 0.75rem; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .h-\[80vh\] { height: 80vh; }
        .min-h-\[500px\] { min-height: 500px; }
        .p-4 { padding: 1rem; }
        .border-b { border-bottom-width: 1px; }
        .border-t { border-top-width: 1px; }
        .border-gray-200 { border-color: #e5e7eb; }
        .bg-gray-50 { background-color: #f9fafb; }
        .rounded-t-xl { border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .font-bold { font-weight: 700; }
        .text-gray-800 { color: #1f2937; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-gray-500 { color: #6b7280; }
        .flex-grow { flex-grow: 1; }
        .overflow-y-auto { overflow-y: auto; }
        .space-y-4 > :not([hidden]) ~ :not([hidden]) { margin-top: 1rem; margin-bottom: 0; }
        .items-start { align-items: flex-start; }
        .items-end { align-items: flex-end; }
        .p-3 { padding: 0.75rem; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .rounded-lg { border-radius: 0.5rem; }
        .max-w-\[85\%\] { max-width: 85%; }
        .text-gray-700 { color: #374151; }
        .text-blue-900 { color: #1e3a8a; }
        .bg-blue-100 { background-color: #dbeafe; }
        .rounded-tr-none { border-top-right-radius: 0; }
        .rounded-tl-none { border-top-left-radius: 0; }
        .whitespace-pre-wrap { white-space: pre-wrap; }
        .space-x-3 > :not([hidden]) ~ :not([hidden]) { margin-right: 0; margin-left: 0.75rem; }
        .border { border-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        .focus\:ring-blue-500:focus { --tw-ring-color: #3b82f6; --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color); }
        .focus\:border-blue-500:focus { border-color: #3b82f6; }
        .transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .duration-150 { transition-duration: 150ms; }
        .px-5 { padding-left: 1.25rem; padding-right: 1.25rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .bg-blue-600 { background-color: #2563eb; }
        .text-white { color: #fff; }
        .font-semibold { font-weight: 600; }
        .shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
        .active\:bg-blue-800:active { background-color: #1e40af; }
        .italic { font-style: italic; }

        /* Styles for Markdown formatting */
        .bot-response h1 { font-size: 1.5rem; font-weight: 700; margin: 0.75rem 0 0.5rem 0; }
        .bot-response h2 { font-size: 1.25rem; font-weight: 700; margin: 0.75rem 0 0.5rem 0; }
        .bot-response h3 { font-size: 1.125rem; font-weight: 700; margin: 0.75rem 0 0.5rem 0; }
        .bot-response strong { font-weight: 700; }
        .bot-response ul, .bot-response ol { margin: 0.5rem 0; padding-left: 1.5rem; }
        .bot-response li { margin: 0.25rem 0; }
        .bot-response p { margin: 0.5rem 0; }

        /* Custom scrollbar style for the chat area */
        #chat-window::-webkit-scrollbar { width: 8px; }
        #chat-window::-webkit-scrollbar-thumb {
            background-color: #d1d5db; /* gray-300 */
            border-radius: 4px;
        }
        
        /* --- Loading Indicator CSS for .dot-flashing --- */
        .dot-flashing {
            position: relative;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #3b82f6; /* blue-600 */
            color: #3b82f6;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: 0.5s;
            display: inline-block;
        }

        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #3b82f6;
            animation: dotFlashing 1s infinite linear alternate;
        }

        .dot-flashing::before {
            left: -12px;
            animation-delay: 0s;
        }

        .dot-flashing::after {
            left: 12px;
            animation-delay: 1s;
        }

        @keyframes dotFlashing {
            0% {
                background-color: #3b82f6;
            }
            50%, 100% {
                background-color: #bfdbfe; /* blue-200 */
            }
        }

        /* --- Microphone Button Styling --- */
        .mic-button {
            background-color: #dc2626; /* red-600 */
            color: #fff;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-size: 1.25rem; /* Larger icon */
            line-height: 1;
            transition: background-color 150ms;
            flex-shrink: 0; /* Prevents it from shrinking */
        }
        .mic-button:hover {
            background-color: #b91c1c; /* red-700 */
        }
        .mic-button.listening {
            background-color: #ef4444; /* red-500, a lighter shade to indicate active state */
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.5); /* Glowing effect */
        }

        /* --- NEW: Mute Button Styling --- */
        .mute-button {
            background-color: #d1d5db; /* gray-300 */
            color: #1f2937; /* gray-800 */
            border: none;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 150ms;
            margin-left: 0.75rem;
        }
        .mute-button:hover {
            background-color: #9ca3af; /* gray-400 */
        }

        /* Adjust header layout to accommodate the button */
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-title-group {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="p-4">

    <div class="w-full max-w-lg bg-white shadow-xl rounded-xl flex flex-col h-[80vh] min-h-[500px]">

        <header class="p-4 border-b border-gray-200 bg-gray-50 rounded-t-xl">
            <div class="header-content">
                <div class="header-title-group">
                    <h1 class="text-lg font-bold text-gray-800">Professional Chatbot Assistant</h1>
                    <p class="text-sm text-gray-500">Tauqeer Ali Khan</p>
                </div>
                <button
                    id="mute-button"
                    class="mute-button"
                    title="Toggle Text-to-Speech"
                >
                    üîä
                </button>
            </div>
            </header>

        <div id="chat-window" class="flex-grow p-4 overflow-y-auto space-y-4">
            <div class="flex flex-col items-start">
                <p class="font-bold text-gray-800">Bot:</p>
                <div class="p-3 bg-gray-100 rounded-lg max-w-[85%] text-gray-700">
                    Hello! I am a chatbot assistant providing information about Tauqeer Ali Khan's Professional Services. How can I assist you?
                </div>
            </div>
            </div>

        <div class="p-4 border-t border-gray-200 flex space-x-3">
            <input
                type="text"
                id="user-input"
                placeholder="Type a message or press the mic button..."
                class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                autocomplete="off"
            >
            <button
                id="mic-button"
                class="mic-button shadow-md transition duration-150"
                title="Voice Input"
            >
                üéôÔ∏è
            </button>
            <button
                id="send-button"
                class="px-5 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150 active:bg-blue-800"
            >
                Send
            </button>
        </div>
    </div>

    <script>
        // Define the Flask server endpoint
        const API_ENDPOINT = 'http://127.0.0.1:8000/chat';
        
        // Corrected session ID generation for robustness
        const sessionID = sessionStorage.getItem('chat_session_id') || crypto.randomUUID();
        sessionStorage.setItem('chat_session_id', sessionID);
    
        // --- NEW GLOBAL STATE VARIABLE ---
        let isMuted = false;
        // ---------------------------------
        
        // Function to detect if the text is predominantly Urdu (Arabic/Persian script)
        // This script check is what determines if we use the ur-PK voice.
        const isUrdu = (text) => {
            // Check for common Urdu/Arabic characters 
            // Note: The model's response in Urdu should use these characters, not Roman Urdu.
            const urduRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]/;
            return urduRegex.test(text);
        };
    
        const parseMarkdownToHTML = (text) => {
            // ... (Keep parseMarkdownToHTML function the same)
            let html = text;
            
            // Convert ### Heading 3 to <h3>
            html = html.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
            
            // Convert ## Heading 2 to <h2>
            html = html.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
            
            // Convert # Heading 1 to <h1>
            html = html.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
            
            // Convert **bold** to <strong>
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em>
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Convert bullet points (* item) to <ul><li>
            const lines = html.split('\n');
            let inList = false;
            let listType = '';
            let result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const isBulletPoint = /^\s*\*\s+/.test(line);
                const isNumberedPoint = /^\s*\d+\.\s+/.test(line);
                
                if (isBulletPoint || isNumberedPoint) {
                    if (!inList) {
                        listType = isBulletPoint ? 'ul' : 'ol';
                        result.push(`<${listType}>`);
                        inList = true;
                    }
                    
                    // Extract the list item text
                    const itemText = line.replace(/^\s*[\*\d+\.]\s+/, '').trim();
                    result.push(`<li>${itemText}</li>`);
                } else {
                    if (inList) {
                        result.push(`</${listType}>`);
                        inList = false;
                        listType = '';
                    }
                    
                    // Handle paragraphs (ignoring empty lines resulting from markdown replacements)
                    if (line.trim() && !line.startsWith('<h')) { 
                        result.push(`<p>${line}</p>`);
                    }
                }
            }
            
            if (inList) {
                result.push(`</${listType}>`);
            }
            
            return result.join('\n');
        };
    
        document.addEventListener('DOMContentLoaded', () => {
            const chatWindow = document.getElementById('chat-window');
            const userInput = document.getElementById('user-input');
            const sendButton = document.getElementById('send-button');
            const micButton = document.getElementById('mic-button');
            const muteButton = document.getElementById('mute-button'); 
    
            // --- Utility Functions ---
    
            const createMessageElement = (sender) => {
                const messageContainer = document.createElement('div');
                messageContainer.classList.add('flex', 'flex-col', 'items-start');
                
                const senderLabel = document.createElement('p');
                senderLabel.classList.add('font-bold', 'text-gray-800');
                senderLabel.textContent = sender === 'user' ? 'You:' : 'Bot:';
                
                const messageBubble = document.createElement('div');
                messageBubble.classList.add('p-3', 'rounded-lg', 'max-w-[85%]');
                
                if (sender === 'user') {
                    messageContainer.classList.add('items-end');
                    messageBubble.classList.add('bg-blue-100', 'text-blue-900', 'rounded-tr-none', 'whitespace-pre-wrap');
                } else {
                    messageBubble.classList.add('bg-gray-100', 'text-gray-700', 'rounded-tl-none', 'bot-response');
                    messageBubble.id = 'bot-response-stream';
                }
                
                messageContainer.appendChild(senderLabel);
                messageContainer.appendChild(messageBubble);
                chatWindow.appendChild(messageContainer);
    
                // Scroll to the latest message
                chatWindow.scrollTop = chatWindow.scrollHeight;
                return messageBubble;
            };
    
            const appendText = (element, text) => {
                // Store accumulated text in a data attribute
                if (!element.dataset.accumulated) {
                    element.dataset.accumulated = '';
                }
                element.dataset.accumulated += text;
                
                // Parse and render the accumulated text as HTML
                const htmlContent = parseMarkdownToHTML(element.dataset.accumulated);
                element.innerHTML = htmlContent;
                
                chatWindow.scrollTop = chatWindow.scrollHeight;
            };
    
            // --- Text-to-Speech Function (FINAL ROBUST VERSION) ---
            const speakText = (text) => {
                if (!('speechSynthesis' in window)) {
                    console.warn("Text-to-Speech not supported in this browser.");
                    return;
                }
    
                // Check MUTE STATE
                if (isMuted) {
                    return; 
                }
                
                window.speechSynthesis.cancel(); 
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0; 
                
                const voices = window.speechSynthesis.getVoices();
                
                let targetLang = 'en-US'; // Default
                let preferredVoice = null;
                
                // 1. Determine if the text is in the Urdu script
                if (isUrdu(text)) {
                    targetLang = 'ur-PK'; 
                    
                    // Look for ur-PK or any ur- voice
                    preferredVoice = voices.find(v => v.lang === 'ur-PK' || v.lang.startsWith('ur-'));
                    
                    // Fallback to related languages (Hindi/Arabic)
                    if (!preferredVoice) {
                        preferredVoice = voices.find(v => v.lang.startsWith('hi') || v.lang.startsWith('ar'));
                    }
                } else {
                    // English or Roman Urdu
                    targetLang = 'en-US';
                    preferredVoice = voices.find(v => v.lang === 'en-US');
                }
                
                // Assign the language and voice
                utterance.lang = targetLang;
                
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                    console.log(`TTS: Found and using voice: ${preferredVoice.name} (${preferredVoice.lang})`);
                } else {
                    console.warn(`TTS: Could not find a specific voice for ${targetLang}. Using browser default.`);
                }
    
                // CRITICAL STEP 2: Pre-process the final text to be spoken
                // This replaces English punctuation with Urdu-compatible equivalents 
                // or just cleans up the text, which sometimes helps the voice engine.
                let cleanText = text.replace(/([,;:\.])/g, ' '); // Replace common English punctuation with space
                
                // If we are using the Urdu voice, we set the final text to the cleaned version
                // This is primarily to prevent the silent skipping behavior.
                if (targetLang === 'ur-PK') {
                     utterance.text = cleanText;
                }
                
                window.speechSynthesis.speak(utterance);
            };
            // --- END Text-to-Speech Function ---
                
            // --- New Streaming Function ---
    
            const streamBotResponse = async (query) => {
                let botMessageElement = createMessageElement('bot');
                botMessageElement.innerHTML = '<span class="dot-flashing"></span>';
    
                let finalResponseText = ''; 
    
                try {
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            query: query,
                            session_id: sessionID
                        })
                    });
    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let done = false;
                    
                    botMessageElement.innerHTML = '';
                    botMessageElement.dataset.accumulated = ''; 
    
                    while (!done) {
                        const { value, done: readerDone } = await reader.read();
                        done = readerDone;
                        const chunk = decoder.decode(value);
                        
                        appendText(botMessageElement, chunk);
                        finalResponseText += chunk;
                    }
                    
                    // --- TTS Activation (Uses updated speakText) ---
                    if (finalResponseText.trim()) {
                        speakText(finalResponseText.trim());
                    }
    
                } catch (error) {
                    // Stop speech if an error occurs
                    window.speechSynthesis.cancel(); 
                    botMessageElement.innerHTML = `<p>Error: Could not connect to the backend server. Is the Flask app running at ${API_ENDPOINT}?</p>`;
                    botMessageElement.style.backgroundColor = '#fecaca'; 
                    console.error('Streaming error:', error);
                }
            };
    
            // --- Event Handler ---
    
            const handleSend = async () => {
                const query = userInput.value.trim();
                if (query === '') return;
    
                // 1. Display User Message
                createMessageElement('user'); 
                const lastUserBubble = chatWindow.lastElementChild.querySelector('div:last-child');
                lastUserBubble.textContent = query;
                userInput.value = '';
                
                sendButton.disabled = true;
                micButton.disabled = true; 
    
                // 2. Stop any ongoing speech
                window.speechSynthesis.cancel();
    
                // 3. Call the actual streaming endpoint
                await streamBotResponse(query);
    
                // 4. Cleanup
                const finalBotResponse = chatWindow.querySelector('#bot-response-stream');
                if (finalBotResponse) {
                    finalBotResponse.removeAttribute('id'); 
                }
                
                sendButton.disabled = false;
                micButton.disabled = false; 
                userInput.focus();
            };
            
            sendButton.addEventListener('click', handleSend);
    
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSend();
                }
            });
            
            // --- NEW: Mute Button Logic ---
            muteButton.addEventListener('click', () => {
                isMuted = !isMuted; // Toggle the state
                
                if (isMuted) {
                    muteButton.textContent = 'üîá'; // Muted icon
                    muteButton.title = 'Text-to-Speech is Muted (Click to Unmute)';
                    window.speechSynthesis.cancel(); // Immediately stop any ongoing speech
                } else {
                    muteButton.textContent = 'üîä'; // Unmuted icon
                    muteButton.title = 'Text-to-Speech is Unmuted (Click to Mute)';
                }
            });
            // --- END Mute Button Logic ---
    
            // --- Speech Recognition Logic (Unchanged but included for completeness) ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = SpeechRecognition ? new SpeechRecognition() : null;
            let isListening = false;
            let userSpoke = false;
    
            if (recognition) {
                recognition.continuous = false;
                recognition.lang = 'en-US';
    
                recognition.onstart = () => {
                    isListening = true;
                    micButton.classList.add('listening');
                    micButton.textContent = 'üõë';
                    userInput.placeholder = "Listening... Speak now.";
                    userInput.disabled = true;
                    sendButton.disabled = true;
                };
    
                recognition.onresult = (event) => {
                    const transcript = Array.from(event.results)
                        .map(result => result[0])
                        .map(result => result.transcript)
                        .join('');
                    
                    userInput.value = transcript;
                    userSpoke = true;
                };
    
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    if (event.error === 'no-speech') {
                        userInput.placeholder = "Didn't catch that. Tap to try again.";
                    } else if (event.error !== 'aborted') {
                            userInput.value = `Error: ${event.error}`;
                    }
                };
    
                recognition.onend = () => {
                    isListening = false;
                    micButton.classList.remove('listening');
                    micButton.textContent = 'üéôÔ∏è';
                    userInput.placeholder = "Type a message or press the mic button...";
                    userInput.disabled = false;
                    sendButton.disabled = false;
                    
                    if (userSpoke && userInput.value.trim() !== '') {
                        handleSend();
                    }
                    userSpoke = false;
                };
    
                micButton.addEventListener('click', () => {
                    // Cancel ongoing speech if user starts talking
                    window.speechSynthesis.cancel();
                    
                    if (isListening) {
                        recognition.stop();
                    } else {
                        userInput.value = ''; 
                        recognition.start();
                    }
                });
            } else {
                micButton.disabled = true;
                micButton.title = 'Speech Recognition not supported in this browser.';
                micButton.textContent = '‚ùå';
                console.error("Web Speech API (Speech Recognition) not supported in this browser.");
            }
            
            userInput.focus();
        });
    </script>

</body>
</html>